import XCTest
@testable import LoyaltyPoints

final class SimpleLoginViewModelTests: XCTestCase {

    func testFormValidationBasic() {
        // Create a simple test without complex mocking
        let authService = SimpleAuthService()
        let networkMonitor = NetworkMonitor() // Use actual NetworkMonitor for simplicity
        let viewModel = LoginViewModel(authService: authService, networkMonitor: networkMonitor)

        // Test initial state
        XCTAssertFalse(viewModel.isFormValid, "Form should start invalid")

        // Set username only
        viewModel.username = "test"

        // Wait briefly for Combine to process
        Thread.sleep(forTimeInterval: 0.1)

        XCTAssertFalse(viewModel.isFormValid, "Form should be invalid with username only")

        // Set both fields
        viewModel.password = "password"

        // Wait briefly for Combine to process
        Thread.sleep(forTimeInterval: 0.1)

        XCTAssertTrue(viewModel.isFormValid, "Form should be valid with both fields")

        // Clear password
        viewModel.password = ""

        // Wait briefly for Combine to process
        Thread.sleep(forTimeInterval: 0.1)

        XCTAssertFalse(viewModel.isFormValid, "Form should be invalid when password cleared")
    }

    func testFormValidationWhitespace() {
        let authService = SimpleAuthService()
        let networkMonitor = NetworkMonitor()
        let viewModel = LoginViewModel(authService: authService, networkMonitor: networkMonitor)

        // Test whitespace handling
        viewModel.username = "   "
        viewModel.password = "   "

        Thread.sleep(forTimeInterval: 0.1)

        XCTAssertFalse(viewModel.isFormValid, "Form should be invalid with whitespace only")
    }

    // MARK: - Test 2: Success → navigation event
    func testSuccessTriggersNavigationEvent() async {
        let authService = SimpleAuthService()
        let networkMonitor = NetworkMonitor()
        let viewModel = LoginViewModel(authService: authService, networkMonitor: networkMonitor)

        viewModel.username = "user"
        viewModel.password = "password"

        XCTAssertEqual(viewModel.state, .idle, "Should start in idle state")

        viewModel.login()

        // Wait for async login to complete
        try? await Task.sleep(nanoseconds: 200_000_000) // 0.2 seconds

        XCTAssertEqual(viewModel.state, .success, "Should be in success state after login")
    }

    // MARK: - Test 3: Error increments failure count
    func testErrorIncrementsFailureCount() async {
        let authService = SimpleAuthService()
        let networkMonitor = NetworkMonitor()
        let viewModel = LoginViewModel(authService: authService, networkMonitor: networkMonitor)

        let initialFailureCount = viewModel.failureCount

        viewModel.username = "wrong"
        viewModel.password = "wrong"

        viewModel.login()

        // Wait for async login to complete
        try? await Task.sleep(nanoseconds: 200_000_000) // 0.2 seconds

        XCTAssertEqual(viewModel.failureCount, initialFailureCount + 1, "Failure count should increment")

        if case .error(let message) = viewModel.state {
            XCTAssertEqual(message, "Invalid username or password", "Should show correct error message")
        } else {
            XCTFail("State should be error")
        }
    }

    // MARK: - Test 4: Lockout after 3 failures
    func testLockoutAfterThreeFailures() async {
        let authService = SimpleAuthService()
        let networkMonitor = NetworkMonitor()
        let viewModel = LoginViewModel(authService: authService, networkMonitor: networkMonitor)

        viewModel.username = "wrong"
        viewModel.password = "wrong"

        // Perform 3 failed attempts
        for _ in 1...3 {
            viewModel.login()
            try? await Task.sleep(nanoseconds: 200_000_000) // 0.2 seconds
        }

        XCTAssertTrue(viewModel.isLockedOut, "Account should be locked after 3 failures")

        // Try another login - should immediately show lockout
        viewModel.login()
        XCTAssertEqual(viewModel.state, .lockedOut, "Should show lockout state")
    }

    // MARK: - Test 5: Offline → show message, no service call
    func testOfflineShowsMessageWithoutServiceCall() {
        let authService = SpyAuthService() // Special spy to count calls
        let networkMonitor = NetworkMonitor()
        let viewModel = LoginViewModel(authService: authService, networkMonitor: networkMonitor)

        // Simulate offline state
        networkMonitor.isConnected = false

        viewModel.username = "user"
        viewModel.password = "password"

        let initialCallCount = authService.loginCallCount

        viewModel.login()

        // No need to wait since it should fail immediately
        XCTAssertEqual(authService.loginCallCount, initialCallCount, "Auth service should not be called when offline")

        if case .error(let message) = viewModel.state {
            XCTAssertEqual(message, "No internet connection", "Should show offline message")
        } else {
            XCTFail("State should be error with offline message")
        }
    }

    // MARK: - Test 6: Remember me persists token
    func testRememberMePersistsToken() async {
        let authService = SpyAuthService()
        let networkMonitor = NetworkMonitor()
        let viewModel = LoginViewModel(authService: authService, networkMonitor: networkMonitor)

        viewModel.username = "user"
        viewModel.password = "password"
        viewModel.rememberMe = true

        viewModel.login()

        // Wait for async login to complete
        try? await Task.sleep(nanoseconds: 200_000_000) // 0.2 seconds

        XCTAssertTrue(authService.saveTokenCalled, "saveToken should be called when rememberMe is true")
        XCTAssertEqual(viewModel.state, .success, "Login should succeed")
    }

    func testRememberMeDisabledDoesNotPersistToken() async {
        let authService = SpyAuthService()
        let networkMonitor = NetworkMonitor()
        let viewModel = LoginViewModel(authService: authService, networkMonitor: networkMonitor)

        viewModel.username = "user"
        viewModel.password = "password"
        viewModel.rememberMe = false

        viewModel.login()

        // Wait for async login to complete
        try? await Task.sleep(nanoseconds: 200_000_000) // 0.2 seconds

        XCTAssertFalse(authService.saveTokenCalled, "saveToken should not be called when rememberMe is false")
        XCTAssertEqual(viewModel.state, .success, "Login should still succeed")
    }
}

// Simple mock that doesn't need complex setup
private class SimpleAuthService: AuthServiceProtocol {
    func login(username: String, password: String) async throws -> AuthToken {
        if username == "user" && password == "password" {
            return AuthToken(token: "test-token", expirationDate: Date().addingTimeInterval(3600))
        } else {
            throw LoginError.invalidCredentials
        }
    }

    func getSavedToken() -> AuthToken? {
        return nil
    }

    func saveToken(_ token: AuthToken) {
        // Mock implementation
    }

    func clearSavedToken() {
        // Mock implementation
    }
}

// Spy service that tracks method calls
private class SpyAuthService: AuthServiceProtocol {
    var loginCallCount = 0
    var saveTokenCalled = false

    func login(username: String, password: String) async throws -> AuthToken {
        loginCallCount += 1

        if username == "user" && password == "password" {
            return AuthToken(token: "test-token", expirationDate: Date().addingTimeInterval(3600))
        } else {
            throw LoginError.invalidCredentials
        }
    }

    func getSavedToken() -> AuthToken? {
        return nil
    }

    func saveToken(_ token: AuthToken) {
        saveTokenCalled = true
    }

    func clearSavedToken() {
        saveTokenCalled = false
    }
}
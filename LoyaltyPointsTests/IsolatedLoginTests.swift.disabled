import XCTest
@testable import LoyaltyPoints

final class IsolatedLoginTests: XCTestCase {

    // MARK: - Test 1: Validation enables/disables button
    func testValidationEnablesDisablesButton() {
        // Create completely isolated test with minimal dependencies
        let authService = TestAuthService()
        let networkMonitor = TestNetworkMonitor()

        let viewModel = LoginViewModel(authService: authService, networkMonitor: networkMonitor)

        // Test initial state - should be invalid
        XCTAssertFalse(viewModel.isFormValid, "Form should be invalid when empty")

        // Set username only - should still be invalid
        viewModel.username = "test"

        // Give time for Combine to process
        let exp1 = XCTestExpectation(description: "Form validation")
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            exp1.fulfill()
        }
        wait(for: [exp1], timeout: 1.0)

        XCTAssertFalse(viewModel.isFormValid, "Form should be invalid with username only")

        // Set both fields - should be valid
        viewModel.password = "password"

        let exp2 = XCTestExpectation(description: "Form validation 2")
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            exp2.fulfill()
        }
        wait(for: [exp2], timeout: 1.0)

        XCTAssertTrue(viewModel.isFormValid, "Form should be valid with both fields")

        // Clear password - should be invalid
        viewModel.password = ""

        let exp3 = XCTestExpectation(description: "Form validation 3")
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            exp3.fulfill()
        }
        wait(for: [exp3], timeout: 1.0)

        XCTAssertFalse(viewModel.isFormValid, "Form should be invalid when password cleared")

        // Test whitespace only
        viewModel.username = "   "
        viewModel.password = "   "

        let exp4 = XCTestExpectation(description: "Form validation 4")
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            exp4.fulfill()
        }
        wait(for: [exp4], timeout: 1.0)

        XCTAssertFalse(viewModel.isFormValid, "Form should be invalid with whitespace only")
    }

    // MARK: - Test 2: Success → navigation event
    func testSuccessTriggersNavigationEvent() async {
        let authService = TestAuthService()
        let networkMonitor = TestNetworkMonitor()
        networkMonitor.isConnected = true

        let viewModel = LoginViewModel(authService: authService, networkMonitor: networkMonitor)

        viewModel.username = "user"
        viewModel.password = "password"

        XCTAssertEqual(viewModel.state, .idle, "Should start in idle state")

        viewModel.login()

        // Wait for async operation
        try? await Task.sleep(nanoseconds: 500_000_000) // 0.5 seconds

        XCTAssertEqual(viewModel.state, .success, "Should be in success state after login")
    }

    // MARK: - Test 3: Error increments failure count
    func testErrorIncrementsFailureCount() async {
        let authService = TestAuthService()
        let networkMonitor = TestNetworkMonitor()
        networkMonitor.isConnected = true

        let viewModel = LoginViewModel(authService: authService, networkMonitor: networkMonitor)

        let initialFailureCount = viewModel.failureCount

        viewModel.username = "wrong"
        viewModel.password = "wrong"

        viewModel.login()

        try? await Task.sleep(nanoseconds: 500_000_000) // 0.5 seconds

        XCTAssertEqual(viewModel.failureCount, initialFailureCount + 1, "Failure count should increment")

        if case .error(let message) = viewModel.state {
            XCTAssertEqual(message, "Invalid username or password", "Should show correct error")
        } else {
            XCTFail("State should be error")
        }
    }

    // MARK: - Test 4: Lockout after 3 failures
    func testLockoutAfterThreeFailures() async {
        let authService = TestAuthService()
        let networkMonitor = TestNetworkMonitor()
        networkMonitor.isConnected = true

        let viewModel = LoginViewModel(authService: authService, networkMonitor: networkMonitor)

        viewModel.username = "wrong"
        viewModel.password = "wrong"

        // Perform 3 failed attempts
        for _ in 1...3 {
            viewModel.login()
            try? await Task.sleep(nanoseconds: 300_000_000) // 0.3 seconds
        }

        XCTAssertTrue(viewModel.isLockedOut, "Account should be locked after 3 failures")

        // Try another login - should immediately show lockout
        viewModel.login()
        XCTAssertEqual(viewModel.state, .lockedOut, "Should show lockout state")
    }

    // MARK: - Test 5: Offline → show message, no service call
    func testOfflineShowsMessageWithoutServiceCall() {
        let authService = SpyTestAuthService()
        let networkMonitor = TestNetworkMonitor()
        networkMonitor.isConnected = false // Simulate offline

        let viewModel = LoginViewModel(authService: authService, networkMonitor: networkMonitor)

        viewModel.username = "user"
        viewModel.password = "password"

        let initialCallCount = authService.loginCallCount

        viewModel.login()

        XCTAssertEqual(authService.loginCallCount, initialCallCount, "Auth service should not be called when offline")

        if case .error(let message) = viewModel.state {
            XCTAssertEqual(message, "No internet connection", "Should show offline message")
        } else {
            XCTFail("State should be error with offline message")
        }
    }

    // MARK: - Test 6: Remember me persists token
    func testRememberMePersistsToken() async {
        let authService = SpyTestAuthService()
        let networkMonitor = TestNetworkMonitor()
        networkMonitor.isConnected = true

        let viewModel = LoginViewModel(authService: authService, networkMonitor: networkMonitor)

        viewModel.username = "user"
        viewModel.password = "password"
        viewModel.rememberMe = true

        viewModel.login()

        try? await Task.sleep(nanoseconds: 500_000_000) // 0.5 seconds

        XCTAssertTrue(authService.saveTokenCalled, "saveToken should be called when rememberMe is true")
        XCTAssertEqual(viewModel.state, .success, "Login should succeed")
    }

    func testRememberMeDisabledDoesNotPersistToken() async {
        let authService = SpyTestAuthService()
        let networkMonitor = TestNetworkMonitor()
        networkMonitor.isConnected = true

        let viewModel = LoginViewModel(authService: authService, networkMonitor: networkMonitor)

        viewModel.username = "user"
        viewModel.password = "password"
        viewModel.rememberMe = false

        viewModel.login()

        try? await Task.sleep(nanoseconds: 500_000_000) // 0.5 seconds

        XCTAssertFalse(authService.saveTokenCalled, "saveToken should not be called when rememberMe is false")
        XCTAssertEqual(viewModel.state, .success, "Login should still succeed")
    }
}

// MARK: - Test Doubles

// Minimal NetworkMonitor replacement
class TestNetworkMonitor: NetworkMonitor {
    private var _isConnected = true

    override var isConnected: Bool {
        get { return _isConnected }
        set { _isConnected = newValue }
    }

    override init() {
        // Don't call super.init() to avoid system network monitoring
        _isConnected = true
    }
}

// Simple auth service for testing
class TestAuthService: AuthServiceProtocol {
    func login(username: String, password: String) async throws -> AuthToken {
        // Minimal delay to simulate network
        try await Task.sleep(nanoseconds: 100_000_000) // 0.1 seconds

        if username == "user" && password == "password" {
            return AuthToken(token: "test-token", expirationDate: Date().addingTimeInterval(3600))
        } else {
            throw LoginError.invalidCredentials
        }
    }

    func getSavedToken() -> AuthToken? {
        return nil
    }

    func saveToken(_ token: AuthToken) {
        // Mock implementation
    }

    func clearSavedToken() {
        // Mock implementation
    }
}

// Spy service that tracks calls
class SpyTestAuthService: AuthServiceProtocol {
    var loginCallCount = 0
    var saveTokenCalled = false

    func login(username: String, password: String) async throws -> AuthToken {
        loginCallCount += 1

        try await Task.sleep(nanoseconds: 100_000_000) // 0.1 seconds

        if username == "user" && password == "password" {
            return AuthToken(token: "test-token", expirationDate: Date().addingTimeInterval(3600))
        } else {
            throw LoginError.invalidCredentials
        }
    }

    func getSavedToken() -> AuthToken? {
        return nil
    }

    func saveToken(_ token: AuthToken) {
        saveTokenCalled = true
    }

    func clearSavedToken() {
        saveTokenCalled = false
    }
}